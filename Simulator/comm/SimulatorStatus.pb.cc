// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: SimulatorStatus.proto

#include "SimulatorStatus.pb.h"
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/wire_format_lite.h>

namespace GUIApp {
namespace Comm {

SimulatorStatus::SimulatorStatus() {
  uptimeseconds_ = 0;
  port_ = 0;
}

SimulatorStatus::~SimulatorStatus() {
}

SimulatorStatus::SimulatorStatus(const SimulatorStatus& from) {
  CopyFrom(from);
}

void SimulatorStatus::CopyFrom(const SimulatorStatus& from) {
  if (&from == this) return;
  ipaddress_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.ipaddress_);
  uptimeseconds_ = from.uptimeseconds_;
  port_ = from.port_;
}

void SimulatorStatus::MergeFrom(const SimulatorStatus& from) {
  if (from.ipaddress().size() > 0) {
    ipaddress_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.ipaddress_);
  }
  if (from.uptimeseconds_ != 0) {
    set_uptimeseconds(from.uptimeseconds_);
  }
  if (from.port_ != 0) {
    set_port(from.port_);
  }
}

void SimulatorStatus::Clear() {
  ipaddress_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  uptimeseconds_ = 0;
  port_ = 0;
}

void SimulatorStatus::Swap(SimulatorStatus* other) {
  if (other == this) return;
  ipaddress_.Swap(&other->ipaddress_, &::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::google::protobuf::internal::ArenaStringPtr::EmptyDefault{});
  std::swap(uptimeseconds_, other->uptimeseconds_);
  std::swap(port_, other->port_);
}

bool SimulatorStatus::IsInitialized() const {
  return true;
}

// Accessors
void SimulatorStatus::clear_ipaddress() {
  ipaddress_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
const ::std::string& SimulatorStatus::ipaddress() const {
  return ipaddress_.GetNoArena();
}
void SimulatorStatus::set_ipaddress(const ::std::string& value) {
  ipaddress_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
}
void SimulatorStatus::set_ipaddress(const char* value) {
  ipaddress_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
}
void SimulatorStatus::set_ipaddress(const char* value, size_t size) {
  ipaddress_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
}
::std::string* SimulatorStatus::mutable_ipaddress() {
  return ipaddress_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
::std::string* SimulatorStatus::release_ipaddress() {
  return ipaddress_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
void SimulatorStatus::set_allocated_ipaddress(::std::string* ipaddress) {
  if (ipaddress != nullptr) {
    ipaddress_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ipaddress);
  } else {
    ipaddress_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), new ::std::string);
  }
}

void SimulatorStatus::clear_uptimeseconds() {
  uptimeseconds_ = 0;
}
::google::protobuf::int32 SimulatorStatus::uptimeseconds() const {
  return uptimeseconds_;
}
void SimulatorStatus::set_uptimeseconds(::google::protobuf::int32 value) {
  uptimeseconds_ = value;
}

void SimulatorStatus::clear_port() {
  port_ = 0;
}
::google::protobuf::int32 SimulatorStatus::port() const {
  return port_;
}
void SimulatorStatus::set_port(::google::protobuf::int32 value) {
  port_ = value;
}

}  // namespace Comm
}  // namespace GUIApp
